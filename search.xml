<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/10/29/JAVA/"/>
      <url>/2023/10/29/JAVA/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h1 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h1><h2 id="常见的CMD命令"><a href="#常见的CMD命令" class="headerlink" title="常见的CMD命令"></a>常见的CMD命令</h2><ol><li>盘符名称+冒号<ul><li>进入对应盘</li></ul></li><li>dir<ul><li>显示当前所有目录以及文件夹</li></ul></li><li>cd<ul><li>cd 目录 进入单级目录</li><li>cd ..  回退到上一级目录</li><li>cd \  回退到盘符</li></ul></li><li>cls<ul><li>清屏</li></ul></li><li>exit<ul><li>退出CMD窗口</li></ul></li></ol><hr><h2 id="JAVA基础内容"><a href="#JAVA基础内容" class="headerlink" title="JAVA基础内容"></a>JAVA基础内容</h2><h3 id="JAVA跨平台"><a href="#JAVA跨平台" class="headerlink" title="JAVA跨平台"></a>JAVA跨平台</h3><ul><li>JAVA语言的跨平台是通过虚拟机实现的。</li><li>JAVA是在虚拟机中还运行，针对不同的平台安装不同的虚拟机就行。</li></ul><h3 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h3><ul><li>JDK是JAVA开发工具包</li><li>JRE是JAVA运行环境</li></ul><p><img src="/./JDK.png" alt="JDK"></p><p><img src="/./JRE.png" alt="JDK"></p><h3 id="JAVA基础概念"><a href="#JAVA基础概念" class="headerlink" title="JAVA基础概念"></a>JAVA基础概念</h3><ol><li><p><strong>注释</strong></p><ul><li>单行注释   &#x2F;&#x2F;</li><li>多行注释  &#x2F;**&#x2F;</li><li>文档注释  &#x2F;**<em>文档信息</em>&#x2F;</li></ul></li><li><p>关键字</p></li><li><p>字面量</p></li><li><p>数据类型</p><ul><li><p>分为基本数据类型和引用数据类型</p></li><li><p>整数</p><p>byte</p><ul><li>整数范围（-128-127）</li></ul><p>short</p><p>int(默认)</p><p>long</p><ul><li>定义long类型的变量，数值后缀需加上L（大小写都可以，建议大写）</li></ul></li><li><p>浮点数</p><ul><li>float<ul><li>定义float类型的变量，数值后缀需加上F（大小写都可以，建议大写）</li></ul></li><li>double</li></ul></li><li><p>字符</p><ul><li>char</li></ul></li><li><p>布尔</p><ul><li>boolean</li></ul></li></ul></li><li><p>标识符</p><ol><li>由数字、字母、下划线（_）和美元符号组成</li><li>不能以数字开头</li><li>不能是关键字</li><li>区分大小写</li></ol><ul><li>小驼峰：方法、变量</li><li>大驼峰：类</li></ul></li><li><p>键盘录入</p><ul><li>Scanner类</li></ul></li><li><p>运算符</p><ul><li>类型转换<ul><li>隐式转换<ul><li>把一个取值范围小的转成取值范围大的</li><li>byte、short、char三种类型的数据在运算的时候，都会先提升为int，然后在进行运算。</li></ul></li><li>强制转换<ul><li>目标数据类型 变量名&#x3D;（目标数据类型）被强制的数据</li></ul></li></ul></li><li>运算符优先级</li></ul></li><li><p>原码反码补码</p></li></ol><ul><li>原码<ul><li>10进制数的二进制表示，最高位为符号位</li></ul></li><li>反码<ul><li>出现的目的<ul><li>为了解决原码不能计算负数的问题</li></ul></li><li>计算规则<ul><li>符号位不变，其他位按位取反</li></ul></li><li>弊端<ul><li>负数运算时，如果结果跨0会和实际结果有1的偏差，因为在反码中，0的反码有两种。</li></ul></li></ul></li><li>补码<ul><li>出现的目的</li><li>为了解决反码负数运算跨0的错误</li><li>计算规则<ul><li>整数的补码和原码一致，负数在反码的基础上最后一位加1</li></ul></li></ul></li></ul><ol start="9"><li><p>方法重载</p><ul><li>在同一个类中，方法名相同，参数不同，与返回值无关。</li><li>参数不同可以指参数个数，参数类型，以及参数顺序</li></ul></li><li><p>面向对象编程</p><ul><li><p>类和对象</p></li><li><p>封装：封装是指将对象的属性和方法封装在一起，使其成为一个独立的单元，只对外部暴露必要的接口。封装可以保护对象的数据安全性，提高代码的可维护性和可重用性。</p><ul><li>privete 关键字修饰的成员只能在本类中才能访问</li><li>Arrays工具类的使用</li></ul></li><li><p>继承：继承是指子类可以继承父类的属性和方法，从而可以重用父类的代码，并且可以在子类中添加新的属性和方法。继承可以减少代码的重复性，提高代码的可维护性和可扩展性。</p><ul><li>使用extends关键字修饰类，表示继承</li><li>支支持单继承，不支持多继承，但支持多层继承</li><li>JAVA中所有的类都直接或者间接继承Object类</li><li>子类到底能继承父类中的那些类容？</li></ul><p><img src="/./Inheritance_relationships.png" alt="继承关系"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/inheriance_1.png" alt="继承中构造方法的访问特点"></p><ul><li><p>方法重写</p><ul><li>当父类的方法不能满足子类现在的需求时，需要进行方法重写。</li><li>使用@override重写注解</li></ul><p>  <img src="/./JAVA%E8%AF%AD%E8%A8%80/function_override_1.png" alt="方法重写的注意事项"></p></li><li><p>多态：多态是指同一个方法可以根据不同的对象调用出不同的行为，即同一种类型的对象在不同的情况下可以表现出不同的行为。多态可以提高代码的灵活性和可扩展性，使代码更容易被修改和维护。</p><ul><li><p>同类型的对象，表现出不同的形态</p></li><li><p>父类类型 对象名称&#x3D;子类对象；</p></li><li><p>前提</p><ul><li>有继承\实现关系</li><li>有父类引用指向子类对象</li><li>有方法的重写</li></ul></li><li><p>多态调用成员的特点</p><ul><li>成员变量<ul><li>编译看左边，运行看左边</li><li>多态情况下，成员变量的访问以引用变量的类型为准，即编译时类型。也就是说，无论引用变量实际指向哪个对象，都只能访问引用变量类型中定义的成员变量。</li></ul></li><li>成员方法<ul><li>编译看左边，运行看右边</li><li>多态情况下，方法的调用以对象的实际类型为准，即运行时类型。也就是说，如果子类重写了父类的方法，那么在调用该方法时，会根据对象的实际类型来决定调用哪个方法。</li></ul></li></ul></li><li><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Polymorphism.png" alt="多态"></p></li></ul></li></ul></li></ul></li></ol><h3 id="6-5-Arrays工具类的使用"><a href="#6-5-Arrays工具类的使用" class="headerlink" title="6.5 Arrays工具类的使用"></a>6.5 Arrays工具类的使用</h3><h2 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7. 字符串"></a>7. 字符串</h2><h3 id="7-1-String类"><a href="#7-1-String类" class="headerlink" title="7.1 String类"></a>7.1 String类</h3><p>字符串的内容不会改变，它的对象的值再创建后不会更改</p><ul><li><p>创建String对象的方式</p><ul><li><p>使用赋值的方法获取一个字符串对象</p><ul><li>存储在StrngTable(串池)，堆区</li></ul></li><li><p>使用new的方式创建</p></li><li><p>传递一个字符数组，根据数组的内容创建</p><pre><code class="java">  char [] chs=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;  String s=new String(chs);</code></pre></li><li><p>传递一个字节数组，根据数组的内容创建</p><pre><code class="java">  byte [] chs=&#123;96,97,98&#125;;  String s=new String(chs);</code></pre></li></ul></li><li><p>常用的方法</p><ul><li><p>字符串比较</p><ul><li>String.equals()<ul><li>比较字符串的大小</li></ul></li><li>String.equalsIgnoreCase()<ul><li>比较字符串的大小，忽略大小写</li></ul></li><li>&#x3D;&#x3D;<ul><li>对于引用数据类型来说，比较的是地址值</li></ul></li></ul></li><li><p>字符串遍历</p><ul><li>String.chatAt(i)<ul><li>获取索引i处的字符</li></ul></li><li>String.length()<ul><li>返回字符串的长度</li></ul></li></ul></li><li><p>字符串截取</p><ul><li>String.subString()</li></ul></li></ul></li></ul><h3 id="7-2-StringBuilder类"><a href="#7-2-StringBuilder类" class="headerlink" title="7.2  StringBuilder类"></a>7.2  StringBuilder类</h3><ul><li>可以看成一个容器，创建之后里面的内容可以改变</li><li>构造方法<ul><li>空参构造</li><li>用一个字符串构造</li></ul></li></ul><h3 id="7-3-StringJoiner-类"><a href="#7-3-StringJoiner-类" class="headerlink" title="7.3 StringJoiner 类"></a>7.3 StringJoiner 类</h3><h2 id="8-集合"><a href="#8-集合" class="headerlink" title="8. 集合"></a>8. 集合</h2><h3 id="8-1-ArrayList类"><a href="#8-1-ArrayList类" class="headerlink" title="8.1 ArrayList类"></a>8.1 ArrayList类</h3><pre><code></code></pre><h3 id="8-2-static关键字"><a href="#8-2-static关键字" class="headerlink" title="8.2 static关键字"></a>8.2 static关键字</h3><p>static 的注意事项</p><ul><li>静态方法只能访问静态变量和静态方法</li><li>非静态方法可以访问静态变量和静态方法，也可以访问非静态的成员变量和方法</li><li>静态方法中没有this关键字</li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包就是文件夹，用来管理各种不同功能的Java类，方便后期代码维护。</p><h3 id="包名的命名规则"><a href="#包名的命名规则" class="headerlink" title="包名的命名规则"></a>包名的命名规则</h3><ul><li>公司的域名反写+包的作用，全部英文小写，见名知意。</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/userOtherClass.png" alt="使用其它类的规则"></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>表示该方法是最终方法，不能被重写和重载</p><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><p>表示该类是最终类，不能被继承</p><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><p>表示该变量是常量，只能被赋值一次</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。</p><p>常量的命名规范:</p><ul><li><p>单个单词：全部大写</p></li><li><p>多个单词:全部大写，单词之间用下划线隔开。</p></li><li><p>final修饰基本数据类型变量: 变量的值不会发生改变。</p></li><li><p>final修饰的变量是引用数据类型:变量存储的地址值不能发生改变，但是对象内部的值可以.</p></li></ul><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><p>用来控制一个成员能够被访问的范围的。可以修饰成员变量，方法，构造方法，内部类。</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/authoity.png" alt="权限修饰符的分类"></p><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><p>写在成员变量的位置，可以把多个构造方法的重复的代码抽取出来，在创建本类对象时，先执行代码块，在执行构造方法。  </p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li>格式<ul><li>static{}</li><li>随着类的加载而加载，只执行一次</li><li>在执行类的初始化的时候用</li></ul></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/abstract.png" alt="抽象类"></p><h4 id="抽象方法的定义格式"><a href="#抽象方法的定义格式" class="headerlink" title="抽象方法的定义格式"></a>抽象方法的定义格式</h4><pre><code class="JAVA">public abstract 返回值类型 方法名(参数列表);</code></pre><h4 id="抽象类和抽象方法的注意事项"><a href="#抽象类和抽象方法的注意事项" class="headerlink" title="抽象类和抽象方法的注意事项"></a>抽象类和抽象方法的注意事项</h4><ul><li>抽象类不能实例化</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类。</li><li>可以有构造方法(可以在创建子类对象时赋值)</li><li>抽象类的子类<ul><li>要么重写所有的抽象方法，要么也是抽象类</li></ul></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/interface.png" alt="接口"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/interface_1.png" alt="接口"></p><h4 id="接口中默认方法的定义格式"><a href="#接口中默认方法的定义格式" class="headerlink" title="接口中默认方法的定义格式"></a>接口中默认方法的定义格式</h4><pre><code>    格式: public default 返回值类型 方法名(参数列表)&#123;&#125;   注意事项：    1.默认方法不是抽象方法，所以不强制重写。但是如果被重写，重写的时候去掉default    2.public可以忽略，但是default不行    3.如果实现了多个接口，多个接口中存在相同名字的默认方法，子类必须对该方法进行重写</code></pre><h4 id="接口中静态方法的定义格式"><a href="#接口中静态方法的定义格式" class="headerlink" title="接口中静态方法的定义格式"></a>接口中静态方法的定义格式</h4><pre><code>格式: public static 返回值类型 方法名(参数列表)&#123;&#125;   注意事项：    1.静态方法只能通过接口名调用，不能通过实现类名或者对象名调用    2.public可以忽略，但是static不行</code></pre><h4 id="接口中私有方法的定义格式"><a href="#接口中私有方法的定义格式" class="headerlink" title="接口中私有方法的定义格式"></a>接口中私有方法的定义格式</h4><pre><code>格式: private static 返回值类型 方法名(参数列表)&#123;&#125;      private  返回值类型 方法名(参数列表)&#123;&#125;</code></pre><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/interface_2.png" alt="接口"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/interface_3.png" alt="接口的总结"></p><h4 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/adapter.png" alt="接口的总结"></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/innerclass.png" alt="内部类"></p><h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><ul><li>写在成员位置的，属于 外部类的成员</li><li>成员内部类可以被一些修饰符所修饰</li><li>在成员内部类里面，JDK16之前不能定义静态常量，JDK16开始才可以。</li></ul><p>获取成员内部类的对象</p><ul><li><p>在外部类中编写方法，对外提供内部类的对象。</p></li><li><p>直接创建格式<br>外部类名.内部类名 对象名&#x3D;new 外部类对象.new 内部类对象</p></li></ul><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>静态内部类只能访问外部类中的静态变量和静态方法，如果想要范文非静态的需要创建对象。</p><ul><li>创建格式</li></ul><p>外部类名.内部类名 对象名&#x3D;new 外部类名.内部类名();</p><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><ol><li>将类定义在方法里面叫做局部内部类</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</li></ol><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类本质上就是隐藏了名字的内部类</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/InnerClass_1.png" alt="匿名内部类"></p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p>对象克隆也称对象拷贝,分为浅拷贝和深拷贝,Object的clone方法是浅拷贝，要实现深拷贝需要重写clone方法</p><ul><li><p>浅拷贝</p><ul><li>不管对象的内部属性是基本数据类型还是引用数据类型都完全拷贝过来（如果是引用数据类型，则拷贝的对象的内部的引用数据属性任然是被拷贝的对象的内部的引用数据属性，更直白一点就是地址相同）</li></ul></li><li><p>深拷贝</p><ul><li>基本数据类型拷贝，字符串复用。引用数据类型会重新创建新的</li></ul></li></ul><h4 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h4><p>Objects是一个工具类</p><h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p>先做非空判断，在比较两个对象</p><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/JDBC.png" alt="JDBC"></p><pre><code class="JAVA"># 连接jdbc步骤// 注册驱动Clsaa.forName(&quot;com.mysql.jdbc.Driver&quot;);//获取连接Connection conn=DriverManager.getConnection(url,username,password);//定义SQL语句String sql=&quot;&quot;;//获取执行SQL对象Statement stmt=conn.createStateMent();//执行SQLstmt.executeUpdate(sql);//处理返回结果//释放资源stmt.close();conn.close();</code></pre><h4 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h4><h5 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h5><ul><li>作用<ul><li><p>注册驱动</p><p> <img src="/./JAVA%E8%AF%AD%E8%A8%80/DriverManager.png" alt="注册驱动"></p></li><li><p>获取连接</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/DriverManage_function_1.png" alt="获取连接"></p></li></ul></li></ul><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><ul><li>作用<ul><li><p>获取执行SQL的对象</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Connection_function.png" alt="注册驱动"></p></li><li><p>事务管理</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Connection_function_1.png" alt="注册驱动"></p></li></ul></li></ul><h5 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h5><ul><li>作用<ul><li>执行SQL语句</li></ul></li></ul><h5 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/ResultSet.png" alt="ResultSet"></p><h5 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/PreparedStatement.png" alt="PreparedStatement"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/PreparedStatement_1.png" alt="PreparedStatement"></p><h5 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/DataSource_1.png" alt="PreparedStatement"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/DataSource.png" alt="PreparedStatement"></p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/regex_group.png" alt="分组"></p><h3 id="JDK8时间类"><a href="#JDK8时间类" class="headerlink" title="JDK8时间类"></a>JDK8时间类</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/JDK8_Date.png" alt="jdk8时间类"></p><h4 id="ZoneId时区"><a href="#ZoneId时区" class="headerlink" title="ZoneId时区"></a>ZoneId时区</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/ZoneId.png" alt="ZoneId时区"></p><h4 id="Instant时间戳"><a href="#Instant时间戳" class="headerlink" title="Instant时间戳"></a>Instant时间戳</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Instant.png" alt="Instant时间戳"></p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>自动装箱:</p><ul><li>把基本数据类型变成其对应的包装类型</li></ul><p>自动拆箱：</p><ul><li>把包装类自动变成其对象的基本数据类型</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/packageclass.png" alt="包装类"></p><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Integer.png" alt="Integer"></p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Lambda.png" alt="Integer"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Lambda1.png" alt="Integer"></p><h3 id="集合进阶"><a href="#集合进阶" class="headerlink" title="集合进阶"></a>集合进阶</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Sets.png" alt="Sets"></p><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><ol><li><p>add</p></li><li><p>remove</p></li><li><p>contains</p></li></ol><p>底层是使用equals方法来判断对象是否一致，如果存的是自定义对象，需要重写equals方法，没有重写equals方法的话，默认使用的时Object类的equals方法进行判断,而Object类中的equals方法，依赖地址值进行判断。</p><h5 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h5><ol><li>迭代器遍历</li></ol><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Iterator.png" alt="迭代器"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Iterator1.png" alt="迭代器1"></p><ol start="2"><li>增强for遍历</li></ol><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/improvefor.png" alt="增强for遍历"></p><ul><li>修改增强for中的变量，原始的集合中的值不会变化</li></ul><ol start="3"><li>lambda表达式遍历</li></ol><pre><code class="JAVA">//利用匿名内部类的形式        collection.forEach(new Consumer&lt;String&gt;() &#123;            @Override            public void accept(String s) &#123;                System.out.println(s);            &#125;        &#125;);//lambda表达式collection.forEach( s -&gt; System.out.println(s));</code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/List.png" alt="List"></p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/ArrayList.png" alt="ArrayList"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/LinkedList.png" alt="LinkedList"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/LinkedList1.png" alt="LinkedList1"></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generics.png" alt="泛型"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generic.png" alt="泛型"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generic1.png" alt="泛型1"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generics1.png" alt="泛型类"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generics2.png" alt="泛型方法"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generics3.png" alt="泛型方法"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generics4.png" alt="泛型接口"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/generics5.png" alt="泛型通配符"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/RedBlackTree.png" alt="红黑树"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/RedBlackTree1.png" alt="红黑树规则"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/RedBlackTree2.png" alt="红黑树规则"></p><h3 id="Set系列集合"><a href="#Set系列集合" class="headerlink" title="Set系列集合"></a>Set系列集合</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/Set.png" alt="Set系列集合"></p><h3 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/hashset.png" alt="HashSet底层原理"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/hashset1.png" alt="哈希值"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/hashset2.png" alt="HashSet底层原理1"></p><ul><li>JDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转成红黑树</li><li>如果集合中存储的是自定义对象，必须要重写hashCode和equals方法,因为它们底层都是用地址值的，我们需要改成属性值。</li></ul><h3 id="LinkedHashSet底层原理"><a href="#LinkedHashSet底层原理" class="headerlink" title="LinkedHashSet底层原理"></a>LinkedHashSet底层原理</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/LinkedHashSet.png" alt="LinkedHashSet底层原理"></p><h3 id="TreeSet底层原理"><a href="#TreeSet底层原理" class="headerlink" title="TreeSet底层原理"></a>TreeSet底层原理</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/TreeSet.png" alt="TreeSet底层原理"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/TreeSet1.png" alt="TreeSet底层原理1"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/TreeSet2.png" alt="TreeSet两种排序方式"></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/map.png" alt="map常用API"></p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/hashmap.png" alt="hashmap特点"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/hashmap1.png" alt="hashmap总结"></p><p><strong>源码分析</strong></p><ul><li>底层元素是Node，实现了Map.Entry&lt;K,V&gt;接口</li><li>加载因子为0.75,最大容量为1&lt;&lt;30.</li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/linkedhashmap.png" alt="linkedhashmap特点"></p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/treemap.png" alt="treemap"></p><ul><li>添加元素时，不需要重写hashCode和equals方法</li></ul><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>JDK5以后添加的功能</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/args.png" alt="可变参数"></p><h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/collections.png" alt="Collections"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/immurable.png" alt="不可变集合"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/immutable.png" alt="不可变集合"></p><h5 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/stream.png" alt="Stream"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/stream1.png" alt="Stream1"></p><h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/func.png" alt="方法引用"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/func1.png" alt="方法引用1"></p><ul><li>引用静态方法<ul><li>格式<ul><li>类名::静态方法</li></ul></li><li>实例<ul><li>Integer::parseInt</li></ul></li></ul></li><li>引用成员方法<ul><li>格式<ul><li>对象::成员方法</li></ul></li></ul></li><li>引用构造方法<ul><li>格式<ul><li>类名::构造方法</li></ul></li></ul></li><li>引用数组的构造方法<ul><li>格式<ul><li>数据类型[]::new</li></ul></li><li>注意事项<ul><li>创建的数据的类型需要和流中数据的类型保持一致</li></ul></li></ul></li></ul><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception.png" alt="异常"></p><h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception1.png" alt="捕获异常"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception2.png" alt="捕获异常"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception3.png" alt="捕获异常"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception4.png" alt="抛出异常"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception5.png" alt="抛出异常"></p><h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/exception6.png" alt="自定义异常"></p><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/file.png" alt="文件"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/file1.png" alt="文件"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/file2.png" alt="文件"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/file3.png" alt="文件"> </p><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO.png" alt="IO的分类"> </p><h5 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h5><ul><li>字节流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO1.png" alt="FileOutPutStream类"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO2.png" alt="FileOutPutStream类"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO3.png" alt="FileInPutStream类"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO4.png" alt="FileInPutStream类"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO5.png" alt="try-catch"> </p><ul><li>字符流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO6.png" alt="字符流"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO7.png" alt="字符流体系"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO8.png" alt="FileReader"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO9.png" alt="FileWriter"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO10.png" alt="FileWriter"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/IO11.png" alt="FileWriter"> </p><ul><li>缓冲流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/buffered.png" alt="缓冲流"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/bytebuffered.png" alt="字节缓冲流"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/charbuffered.png" alt="字符缓冲流"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/bufferedstreamsummary.png" alt="总结"> </p><ul><li>转换流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/summarytransfer.png" alt="总结"> </p><ul><li>序列化流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/objectstream.png" alt="序列化流"></p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/objectstream1.png" alt="序列化流"> </p><ul><li>反序列化流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81.png" alt="反序列化流"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/summaryofstream.png" alt="反序列化流"> </p><ul><li>打印流</li></ul><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/printstream.png" alt="打印流"> </p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li><p>并发</p><ul><li>在同一时刻，有多个指令在单个CPU上交替运行</li></ul></li><li><p>并行</p><ul><li>在同一时刻，有多个指令在多个CPU上同时运行</li></ul></li></ul><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><ol><li><p>继承Thread类的方式进行实现</p><ul><li>继承Thread类，</li><li>重写run方法，</li><li>创建子类对象，然后调用start方法。</li></ul></li><li><p>实现Runnable接口的方式进行实现</p><ul><li>创建一个类实现Runnable接口，</li><li>重写run方法，</li><li>创建自己的类的对象，创建Thread对象，然后调用start方法。</li></ul></li><li><p>利用Callable接口和Future接口方式实现<br> 1.创建一个类实现Callable接口，<br> 2.重写call方法(有返回值，表示多线程运行的结果)，</p><p> 3.创建自己的类的对象<br> 4.创建FutureTask对象(作用：管理多线程运行的结果)<br> 5.创建Thread对象并调用start方法</p></li></ol><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/thread.png" alt="三种方式"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/thread1.png" alt="常见方法"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/thread2.png" alt="生命周期"> </p><p><strong>JAVA中线程的生命周期</strong></p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 start() 。</li><li>RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><strong>死锁</strong><br>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><strong>产生死锁的四个必要条件</strong></p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/thread3.png" alt="生命周期"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/synchronized.png" alt="同步方法"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/threadpool.png" alt="线程池"> </p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/threadpool1.png" alt="线程池"> </p><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><p>IP + 端口 + 协议</p><p><img src="/./JAVA%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png" alt="线程池"> </p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>可重入互斥锁，可以使用isHeldByCurrentThread或getHoldCount进行检查当前线程是否拥有锁。</p><p>构造方法有两个，一个是无参ReentrantLock()非公平锁，另外一个接受可选的公平参数ReentrantLock(boolean fair)</p><p>常用方法<br>-Lock：</p><ul><li><p>获取锁。如果锁未被另一个线程持有，则获取锁并立即返回，将锁保持计数设置为 1。如果当前线程已持有锁，则保留计数将递增 1，并且该方法会立即返回。如果锁由另一个线程持有，则当前线程将出于线程调度目的而被禁用，并处于休眠状态，直到获取锁为止，此时锁保持计数设置为 1。</p></li><li><p>底层使用CAS操作设置state的值</p></li></ul><p>二叉树的性质</p><ol><li>在二叉树的第i层上至多有$2^i-1$个结点（i&gt;&#x3D;1）。</li><li>深度为k的二叉树至多有$2^k-1$个结点（k&gt;&#x3D;1）。</li><li>对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/28/hello-world/"/>
      <url>/2023/10/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
